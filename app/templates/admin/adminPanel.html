{% extends "layout.html" %}
{% block title %}
Admin Panel
{% endblock title %}
{% block text %}
Willkommen im Admin Panel
{% endblock text %}
{% block content %}
<div class="flex flex-col h-screen">
  <div class="sticky top-0 z-50 p-4 bg-gray-200 border-b border-gray-300"> 
    <label for="tables" class="block text-sm font-semibold text-gray-700">Select a table:</label> 
    <select id="tables" class="block w-full px-4 py-2 text-base text-gray-700 transition-colors bg-white rounded-lg shadow-sm focus:outline-none focus:ring-2 focus:ring-green-500 focus:border-transparent hover:bg-gray-200" onchange="handleTableSelection()">
      <option value="">Select table</option>
      {% for table in tables %}
      <option value="{{ table }}">{{ table }}</option>
      {% endfor %}
    </select>
  </div>
  <div class="flex-grow overflow-hidden bg-gray-50">
    <div class="w-full h-full overflow-x-auto">
      <table id="dynamic-table" class="min-w-full bg-white divide-y divide-gray-200 rounded-lg shadow-lg"> 
        <thead id="table-head" class="bg-gray-300">
          <!-- Dynamic Headers will be inserted here -->
        </thead>
        <tbody id="table-body" class="divide-y divide-gray-200">
          <!-- Dynamic Data will be inserted here -->
        </tbody>
      </table>
    </div>
  </div>
</div>


<script>
function clearTable(tableBody, tableHead) {
  tableBody.innerHTML = "";
  tableHead.innerHTML = "";
}

function createElement(tagName, classes, innerText) {
  const elem = document.createElement(tagName);
  elem.className = classes;
  elem.innerText = innerText;
  return elem;
}

async function fetchAndUpdate(url, method, body) {
  try {
    const response = await fetch(url, {
      method,
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(body),
    });
    return await response.json();
  } catch (error) {
    console.error('Error:', error);
    return null;
  }
}

// Load Table Data
async function loadTableData(table_name) {
  const tableBody = document.getElementById('table-body');
  const tableHead = document.getElementById('table-head');
  clearTable(tableBody, tableHead);
  
  const data = await fetchAndUpdate(`/table/${table_name}`, 'GET');

  if (data && data.length > 0) {
    const headerRow = createElement('tr', '', '');
    Object.keys(data[0]).forEach(key => {
      const th = createElement('th', 'px-6 py-3 text-xs font-medium tracking-wider text-left text-gray-600 uppercase', key);
      headerRow.appendChild(th);
    });
    tableHead.appendChild(headerRow);

    data.forEach(row => {
      const tr = createElement('tr', 'hover:bg-gray-100', ''); 
      Object.keys(row).forEach(key => {
        const td = createElement('td', 'px-6 py-4 text-sm text-gray-600 whitespace-nowrap', row[key]);
        td.onclick = (event) => convertToInput(td, table_name, row.id, key, event);
        tr.appendChild(td);
      });
      tableBody.appendChild(tr);
    });
  }
};

// Handle Table Selection
function handleTableSelection() {
  const selectedTable = document.querySelector("#tables").value;
  if (selectedTable) loadTableData(selectedTable);
}

let activeCell = null;

// Helper function to remove event listeners
function removeEventListenerById(id, event, listener) {
  const elem = document.getElementById(id);
  if (elem) elem.removeEventListener(event, listener);
}

// Create input element with attributes
function createInputElem(originalText) {
  const inputElem = createElement('input', 'input-field ', '');
  inputElem.type = 'text';
  inputElem.value = originalText;
  return inputElem;
}

const nonEditableFields = {
  'meldungen': ['id', 'fo_zuordnung'],
  'beschreibung': ['id'],
  'fundorte': ['id', 'ablage', 'beschreibung'],
  'melduser': ['id', 'id_finder', 'id_meldung', 'id_user'],
  'users': ['id', 'user_id']
};

// Convert TD to Input
function convertToInput(tdElem, table_name, row_id, column_name, event) {
  console.log(`Table: ${table_name}, Column: ${column_name}`); // Debugging output
  event.stopPropagation();

  // Check if the field is non-editable and return without doing anything if it is
  if (nonEditableFields[table_name] && nonEditableFields[table_name].includes(column_name)) {
    console.log(`Editing prevented for ${table_name} -> ${column_name}`); // Debugging output
    return;
  }
  event.stopPropagation();
  if (tdElem.querySelector('.edit-button')) return;
  if (activeCell) resetToBefore(activeCell);

  const originalText = tdElem.innerText;
  const editButton = createElement('button', 'bg-blue-500 hover:bg-blue-700 text-white font-bold py-1 px-2 rounded edit-button ml-2', 'Edit');
  editButton.onclick = () => {
    const inputDiv = createElement('div', 'relative flex items-center', '');
    const inputElem = createInputElem(originalText);
    const updateButton = createElement('button', 'absolute right-3 top-1/2 transform -translate-y-1/2 bg-green-500 hover:bg-green-700 text-white font-bold py-1 px-2 rounded focus:outline-none', 'Update'); // <-- Modified right positioning
        
    inputElem.addEventListener("keydown", (event) => {
      if (event.key === "Escape") resetToBefore({ tdElem, originalText, table_name, row_id, column_name });
    });

    inputDiv.appendChild(inputElem);
    inputDiv.appendChild(updateButton);
    tdElem.innerHTML = '';
    tdElem.appendChild(inputDiv);
    inputElem.focus();
    tdElem.onclick = null;

    updateButton.onclick = () => convertToText(inputDiv, table_name, row_id, column_name);

    document.addEventListener('click', (event) => {
      if (!inputDiv.contains(event.target) && event.target !== editButton) {
        resetToBefore({ tdElem, originalText, table_name, row_id, column_name });
      }
    }, { once: true });
  };

  tdElem.innerHTML = '';
  tdElem.appendChild(document.createTextNode(originalText));
  tdElem.appendChild(editButton);

  activeCell = { tdElem, originalText, table_name, row_id, column_name };
};

// Reset to Before
function resetToBefore({ tdElem, originalText, table_name, row_id, column_name }) {
  tdElem.innerHTML = originalText;
  tdElem.onclick = (event) => convertToInput(tdElem, table_name, row_id, column_name, event);
  activeCell = null;
}


// Convert Div to Text and Update
async function convertToText(divElem, table_name, row_id, column_name) {
  const inputElem = divElem.querySelector('input');
  const newValue = inputElem.value;
  const updateResponse = await fetchAndUpdate(`/update_value/${table_name}/${row_id}`, 'POST', { column_name, new_value: newValue });

  if (updateResponse && updateResponse.status === 'success') {
      const td = divElem.parentElement;
      resetToBefore({ tdElem: td, originalText: newValue, table_name, row_id, column_name });
  } else {
      console.error('Update failed');
  }
}

</script>
  
  {% endblock content %}