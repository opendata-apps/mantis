{% extends "layout.html" %}
{% block title %}Fundmeldungen 2023{% endblock title %}
{% block meta_keywords %} Auswertungen, Karte,
Gottesanbeterin, Mantis religiosa Auswertungen {% endblock %}
{% block text %} Übersicht zu allen bestätigten Meldungen. {% endblock text %}
{% block content %}
<section class="container mx-auto mt-10">
  <h2 class="mb-6 text-3xl font-semibold text-center">Bestätigte Meldungen Karte</h2>
  <div class="container flex flex-row p-6">
    <div id="map" class="object-fill h-screen bg-white rounded-lg shadow-md grow auto-rows-max"></div>
  </div>
</section>

<!-- Animated counter section -->
<section class="py-16 bg-gray-100">
  <div class="container px-4 mx-auto">
    <div class="relative px-8 py-12 bg-green-800 rounded-lg shadow-2xl">
      <h2 class="mb-8 text-3xl font-bold leading-tight text-center text-white">
        Wir haben bereits <br />
        <span class="font-extrabold text-white text-7xl counter" data-target="{{ post_count }}">0</span>
        <br />
        Meldungen erhalten
      </h2>
      <p class="mb-8 text-xl text-center text-white">
        Helfen Sie uns, diese Zahl zu erhöhen!
      </p>
    </div>
  </div>
</section>


<script>
  const counter = document.querySelector('.counter');
  const target = Math.min(+counter.dataset.target, {{ post_count }});
  const duration = 2500; 

  let startTime = null;

  function easeOutExpo(time, b, c, d) {
    return c * (-Math.pow(2, -10 * time / d) + 1) + b;
  }

  function animate(currentTime) {
    if (startTime === null) startTime = currentTime;
    const elapsedTime = currentTime - startTime;
    const progress = Math.min(elapsedTime / duration, 1);

    const count = Math.floor(easeOutExpo(progress, 0, target, 1));
    counter.innerText = count;

    if (elapsedTime < duration) {
      requestAnimationFrame(animate);
    } else {
      counter.innerText = target; // Ensure it ends on the target
    }
  }

  const observer = new IntersectionObserver(entries => {
    if (entries[0].isIntersecting) {
      requestAnimationFrame(animate);
      observer.disconnect();
    }
  });

  observer.observe(counter);



let map;
let userMarker;
mapApiKey = "{{apikey}}"

function initMap() {
  // Define the boundary box for Germany
  const germanyBounds = [
    [47.270111, 5.866342], // Southwest corner
    [55.058347, 15.041896]  // Northeast corner
  ];

  map = L.map('map', {
    maxBounds: germanyBounds,
    maxBoundsViscosity: 1.0
  }).setView([51.991649, 13.080113], 9);

  // Define map layers
  const openStreetMapLayer = L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
    attribution: 'Map data &copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors',
    maxZoom: 12,
  });

  const arcGISLayer = L.esri.Vector.vectorBasemapLayer("ArcGIS:Imagery", {
    apikey: mapApiKey // API key for ArcGIS
  
  });

  // Add default layer to the map
  map.addLayer(openStreetMapLayer);

  // Layer switcher control
  var baseMaps = {
    "Karte": openStreetMapLayer,
    "Satellit": arcGISLayer
  };

  L.control.layers(baseMaps).addTo(map);

  var reports = JSON.parse('{{ reportsJson | safe }}');
  for (var i = 0; i < reports.length; i++) {
    var report = reports[i];
    const marker = L.marker([report.latitude, report.longitude]).addTo(map)
  };

  // Add an event listener to the map to enforce maxZoom for all layers
  const MAX_ZOOM_LEVEL = 12;
  map.on('zoomend', function() {
    if (map.getZoom() > MAX_ZOOM_LEVEL) {
      map.setZoom(MAX_ZOOM_LEVEL);
    }
  });

  const MIN_ZOOM_LEVEL = 6;  // adjust as needed
  map.on('zoomend', function() {
    if (map.getZoom() < MIN_ZOOM_LEVEL) {
      map.setZoom(MIN_ZOOM_LEVEL);
    }
  });
};

initMap();
</script>

{% endblock content %}

